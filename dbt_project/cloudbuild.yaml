# ---- cloudbuild.yaml FINAL Y SIMPLIFICADO ----

steps:
  # --- PASO 0: Construir la imagen con AMBOS tags (SHA y latest) ---
  - name: 'gcr.io/cloud-builders/docker'
    id: 'build-dbt-image'
    args:
      - 'build'
      # Crea el tag único con el SHA del commit
      - '--tag=$_IMAGE_TAG'
      # Crea también el tag 'latest' para el caché
      - '--tag=$_LOCATION-docker.pkg.dev/$PROJECT_ID/$_REPOSITORY/dbt-transform-job:latest'
      - '--cache-from=$_LOCATION-docker.pkg.dev/$PROJECT_ID/$_REPOSITORY/dbt-transform-job:latest'
      - '.'
    timeout: 1200s

  # --- PASO 1: Escanear la imagen (ahora que la API estará habilitada) ---
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'scan-for-vulnerabilities'
    waitFor: ['build-dbt-image']
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        gcloud artifacts docker images scan $_IMAGE_TAG --format=json > scan_results.json
        if grep -q -E "CRITICAL|HIGH" scan_results.json; then
          echo "❌ Vulnerabilidades críticas o altas encontradas."
          cat scan_results.json
          exit 1
        else
          echo "✅ No se encontraron vulnerabilidades críticas o altas."
        fi

  # --- PASO 2: Desplegar el Job en Cloud Run ---
  # Este paso YA funciona, pero ahora lo hará después de un escaneo correcto.
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'deploy-to-cloud-run'
    waitFor: ['scan-for-vulnerabilities']
    args:
      - 'run'
      - 'jobs'
      - 'update'
      - '$_JOB_NAME'
      - '--image=$_IMAGE_TAG'
      - '--region=$_REGION'
      - '--quiet'

# --- IMÁGENES A SUBIR ---
# Ahora Cloud Build encontrará AMBOS tags localmente y los subirá.
images:
  - '$_IMAGE_TAG'
  - '$_LOCATION-docker.pkg.dev/$PROJECT_ID/$_REPOSITORY/dbt-transform-job:latest'

# --- OPCIONES ---
options:
  logging: CLOUD_LOGGING_ONLY

# --- CUENTA DE SERVICIO ---
serviceAccount: projects/$PROJECT_ID/serviceAccounts/cloud-run-build-sa@dwhfinancial.iam.gserviceaccount.com